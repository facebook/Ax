#!/usr/bin/env python3

from collections import OrderedDict
from datetime import datetime
from enum import Enum
from typing import Dict, List, MutableMapping, NamedTuple, Optional, Tuple

import pandas as pd
from ae.lazarus.ae.core.base import Base
from ae.lazarus.ae.core.condition import Condition
from ae.lazarus.ae.core.optimization_config import OptimizationConfig
from ae.lazarus.ae.core.search_space import SearchSpace
from ae.lazarus.ae.core.types.types import TModelPredict, TModelPredictCondition


class GeneratorRunType(Enum):
    """Class for enumerating generator run types."""

    STATUS_QUO = 0


class ConditionWeight(NamedTuple):
    """NamedTuple for tying together conditions and weights."""

    condition: Condition
    weight: float


def extract_condition_predictions(
    model_predictions: TModelPredict, condition_idx: int
) -> TModelPredictCondition:
    """Extract a particular condition from model_predictions.

    Args:
        model_predictions: Mean and Cov for all conditions.
        condition_idx: Index of condition in prediction list.

    Returns:
        (mean, cov) for specified condition.
    """

    means = model_predictions[0]
    covariances = model_predictions[1]
    means_per_condition = {
        metric: means[metric][condition_idx] for metric in means.keys()
    }
    covar_per_condition = {
        metric: {
            other_metric: covariances[metric][other_metric][condition_idx]
            for other_metric in covariances[metric].keys()
        }
        for metric in covariances.keys()
    }
    return (means_per_condition, covar_per_condition)


class GeneratorRun(Base):
    """An object that represents a single run of a generator.

    This object is created each time the ``gen`` method of a generator is
    called. It stores the conditions and (optionally) weights that were
    generated by the run. When we add a generator run to a trial, its
    conditions and weights will be merged with those from previous generator
    runs that were already attached to the trial.
    """

    def __init__(
        self,
        conditions: List[Condition],
        weights: Optional[List[float]] = None,
        optimization_config: Optional[OptimizationConfig] = None,
        search_space: Optional[SearchSpace] = None,
        model_predictions: Optional[TModelPredict] = None,
        best_condition_predictions: Optional[
            Tuple[Condition, Optional[TModelPredictCondition]]
        ] = None,
        type: Optional[str] = None,
        fit_time: Optional[float] = None,
        gen_time: Optional[float] = None,
    ) -> None:
        """
        Inits GeneratorRun.

        Args:
            conditions: The list of conditions generated by this run.
            weights: An optional list of weights to associate with the conditions.
            optimization_config: The optimization config used during generation
                of this run.
            search_space: The search used during generation of this run.
            model_predictions: Means and covariances for the conditions in this
                run recorded at the time the run was executed.
            best_condition_predictions: Optional tuple of best condition in this run
                (according to the optimization config) and its optional respective
                model predictions.
            type: Optional type of the run.
            fit_time: Optional number of seconds it took to fit the model that produced
                this generator run.
            gen_time: Optional number of seconds generation took.
        """
        self._condition_weight_table: OrderedDict[str, ConditionWeight] = OrderedDict()
        if weights is None:
            weights = [1.0 for i in range(len(conditions))]
        if len(conditions) != len(weights):
            raise ValueError("Weights and conditions must have the same length.")
        for condition, weight in zip(conditions, weights):
            existing_cw = self._condition_weight_table.get(condition.signature)
            if existing_cw:
                self._condition_weight_table[condition.signature] = ConditionWeight(
                    condition=condition, weight=existing_cw.weight + weight
                )
            else:
                self._condition_weight_table[condition.signature] = ConditionWeight(
                    condition=condition, weight=weight
                )

        self._generator_run_type: Optional[str] = type
        self._time_created: datetime = datetime.now()
        self._optimization_config = optimization_config
        self._search_space = search_space
        self._model_predictions = model_predictions
        self._best_condition_predictions = best_condition_predictions
        self._index: Optional[int] = None
        self._fit_time = fit_time
        self._gen_time = gen_time

    @property
    def conditions(self) -> List[Condition]:
        """Returns conditions generated by this run."""
        return [cw.condition for cw in self._condition_weight_table.values()]

    @property
    def weights(self) -> List[float]:
        """Returns weights associated with conditions generated by this run."""
        return [cw.weight for cw in self._condition_weight_table.values()]

    @property
    def condition_weights(self) -> MutableMapping[Condition, float]:
        """Mapping from conditions to weights (order matches order in
        `conditions` property).

        """
        return OrderedDict(zip(self.conditions, self.weights))

    @property
    def generator_run_type(self) -> Optional[str]:
        """The type of the generator run."""
        return self._generator_run_type

    @property
    def time_created(self) -> datetime:
        """Creation time of the batch."""
        return self._time_created

    @property
    def index(self) -> Optional[int]:
        """The index of this generator run within a trial's list of generator run structs.
        This field is set when the generator run is added to a trial.
        """
        return self._index

    @index.setter
    def index(self, index: int) -> None:
        if self._index is not None and self._index != index:
            raise ValueError("Cannot change the index of a generator run once set.")
        self._index = index

    @property
    def optimization_config(self) -> Optional[OptimizationConfig]:
        """The optimization config used during generation of this run."""
        return self._optimization_config

    @property
    def search_space(self) -> Optional[SearchSpace]:
        """The search used during generation of this run."""
        return self._search_space

    @property
    def model_predictions(self) -> Optional[TModelPredict]:
        return self._model_predictions

    @property
    def fit_time(self) -> Optional[float]:
        return self._fit_time

    @property
    def gen_time(self) -> Optional[float]:
        return self._gen_time

    @property
    def model_predictions_by_condition(
        self
    ) -> Optional[Dict[str, TModelPredictCondition]]:
        if self._model_predictions is None:
            return None

        predictions: Dict[str, TModelPredictCondition] = {}
        for idx, cond in enumerate(self.conditions):
            predictions[cond.signature] = extract_condition_predictions(
                model_predictions=self._model_predictions, condition_idx=idx
            )
        return predictions

    @property
    def best_condition_predictions(
        self
    ) -> Optional[Tuple[Condition, Optional[TModelPredictCondition]]]:
        return self._best_condition_predictions

    @property
    def param_df(self) -> pd.DataFrame:
        """
        Constructs a Pandas dataframe with the parameter values for each condition.

        Useful for inspecting the contents of a generator run.

        Returns:
            pd.DataFrame: a dataframe with the generator run's conditions.
        """
        return pd.DataFrame.from_dict(
            {a.name_or_short_signature: a.params for a in self.conditions},
            orient="index",
        )

    def __repr__(self) -> str:
        class_name = self.__class__.__name__
        num_conditions = len(self.conditions)
        total_weight = sum(self.weights)
        return f"{class_name}({num_conditions} conditions, total weight {total_weight})"
