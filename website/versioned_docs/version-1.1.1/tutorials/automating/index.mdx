---
title: Automating Orchestration
sidebar_label: Automating Orchestration
---

import LinkButtons from "@site/src/components/LinkButtons.jsx";
import CellOutput from "@site/src/components/CellOutput.jsx";
import {PlotlyFigure} from "@site/src/components/Plotting.jsx";

<LinkButtons
  githubUrl="https://github.com/facebook/ax/blob/main/tutorials/automating/automating.ipynb"
  colabUrl="https://colab.research.google.com/github/facebook/ax/blob/main/tutorials/automating/automating.ipynb"
/>

# Automating Orchestration

Previously, we've demonstrated [using Ax for ask-tell optimization](../getting_started),
a paradigm in which we "ask" Ax for candidate configurations and "tell" Ax our
observations. This can be effective in many scenerios, and it can be automated through
use of flow control statements like `for` and `while` loops. However there are some
situations where it would be beneficial to allow Ax to orchestrate the entire
optimization: deploying trials to external systems, polling their status, and reading
reading their results. This can be common in a number of real world engineering tasks,
including:

- **Large scale machine learning experiments** running workloads on high-performance
  computing clusters
- **A/B tests** conducted using an external experimentation platform
- **Materials science** optimizations utilizing a self-driving laboratory

Ax's `Client` can orchestrate automated adaptive experiments like this using its method
`run_trials`. Users create custom classes which implement Ax's `IMetric` and `IRunner`
protocols to handle data fetching and trial deployment respectively. Then, users simply
configure their `Client` as they would normally and call `run_trials`; Ax will deploy
trials, fetch data, generate candidates, and repeat as necessary. Ax can manage complex
orchestration tasks including launching multiple trials in parallel while still
respecting a user-defined concurrency limit, and gracefully handling trial failure by
allowing the experiment to continue even if some trials do not complete successfully or
data fetching fails.

In this tutorial we will optimize the Hartmann6 function as before, but we will
configure custom Runners and Metrics to mimic an external execution system. The Runner
will calculate Hartmann6 with the appropriate parameters, write the result to a file,
and tell Ax the trial is ready after 5 seconds. The Metric will find the appropriate
file and report the results back to Ax.

### Learning Objectives

- Learn when it can be appropriate and/or advantageous to run Ax in a closed-loop
- Configure custom Runners and Metrics, allowing Ax to deploy trials and fetch data
  automatically
- Understand tradeoffs between parallelism and optimization performance

### Prerequisites

- Understanding of [adaptive experimentation](../../intro-to-ae.mdx) and
  [Bayesian optimization](../../intro-to-bo.mdx)
- Familiarity with
  [configuring and conducting experiments in Ax](../getting_started/index.mdx)

## Step 1: Import Necessary Modules

First, ensure you have all the necessary imports:

```python
import os
import time
from typing import Any, Mapping

import numpy as np
from ax.api.client import Client
from ax.api.configs import RangeParameterConfig
from ax.api.protocols.metric import IMetric
from ax.api.protocols.runner import IRunner, TrialStatus
from ax.api.types import TParameterization
```

# Step 2: Defining our custom Runner and Metric

As stated before, we will be creating custom Runner and Metric classes to mimic an
external system. Let's start by defining our Hartmann6 function as before.

```python
# Hartmann6 function
def hartmann6(x1, x2, x3, x4, x5, x6):
    alpha = np.array([1.0, 1.2, 3.0, 3.2])
    A = np.array([
        [10, 3, 17, 3.5, 1.7, 8],
        [0.05, 10, 17, 0.1, 8, 14],
        [3, 3.5, 1.7, 10, 17, 8],
        [17, 8, 0.05, 10, 0.1, 14]
    ])
    P = 10**-4 * np.array([
        [1312, 1696, 5569, 124, 8283, 5886],
        [2329, 4135, 8307, 3736, 1004, 9991],
        [2348, 1451, 3522, 2883, 3047, 6650],
        [4047, 8828, 8732, 5743, 1091, 381]
    ])

    outer = 0.0
    for i in range(4):
        inner = 0.0
        for j, x in enumerate([x1, x2, x3, x4, x5, x6]):
            inner += A[i, j] * (x - P[i, j])**2
        outer += alpha[i] * np.exp(-inner)
    return -outer

hartmann6(0.1, 0.45, 0.8, 0.25, 0.552, 1.0)
```

<CellOutput>
{
`np.float64(-0.4878737485613134)`
}
</CellOutput>

Next, we will define the `MockRunner`. The `MockRunner` requires two methods:
`run_trial` and `poll_trial`.

`run_trial` deploys a trial to the external system with the given parameters. In this
case, we will simply save a file containing the result of a call to the Hartmann6
function.

`poll_trial` queries the external system to see if the trial has completed, failed, or
if it's still running. In this mock example, we will check to see how many seconds have
elapsed since the `run_trial` was called and only report a trial as completed once 5
seconds have elapsed.

Runner's may also optionally implement a `stop_trial` method to terminate a trial's
execution before it has completed. This is necessary for using
[early stopping](../early_stopping) in closed-loop experimentation, but we will skip
this for now.

```python
class MockRunner(IRunner):
    def run_trial(
        self, trial_index: int, parameterization: TParameterization
    ) -> dict[str, Any]:
        file_name = f"{int(time.time())}.txt"

        x1 = parameterization["x1"]
        x2 = parameterization["x2"]
        x3 = parameterization["x3"]
        x4 = parameterization["x4"]
        x5 = parameterization["x5"]
        x6 = parameterization["x6"]

        result = hartmann6(x1, x2, x3, x4, x5, x6)

        with open(file_name, "w") as f:
            f.write(f"{result}")

        return {"file_name": file_name}

    def poll_trial(
        self, trial_index: int, trial_metadata: Mapping[str, Any]
    ) -> TrialStatus:
        file_name = trial_metadata["file_name"]
        time_elapsed = time.time() - int(file_name[:4])

        if time_elapsed < 5:
            return TrialStatus.RUNNING

        return TrialStatus.COMPLETED
```

It's worthwhile to instantiate your Runner and test it is behaving as expected. Let's
deploy a mock trial by manually calling `run_trial` and ensuring it creates a file.

```python
runner = MockRunner()

trial_metadata = runner.run_trial(
    trial_index=-1,
    parameterization={
        "x1": 0.1,
        "x2": 0.45,
        "x3": 0.8,
        "x4": 0.25,
        "x5": 0.552,
        "x6": 1.0,
    },
)

os.path.exists(trial_metadata["file_name"])
```

<CellOutput>
{
`True`
}
</CellOutput>

Now, we will implement the Metric. Metrics only need to implement a `fetch` method,
which returns a progression value (i.e. a step in a timeseries) and an observation
value. Note that the observation can either be a simple float or a (mean, SEM) pair if
the external system can report observed noise.

In this case, we have neither a relevant progression value nor observed noise so we will
simply read the file and report `(0, value)`.

```python
class MockMetric(IMetric):
    def fetch(
        self,
        trial_index: int,
        trial_metadata: Mapping[str, Any],
    ) -> tuple[int, float | tuple[float, float]]:
        file_name = trial_metadata["file_name"]

        with open(file_name, 'r') as file:
            value = float(file.readline())
            return (0, value)
```

Again, let's validate the Metric created above by instantiating it and reporting the
value from the file generated during testing of the Runner.

```python
# Note: all Metrics must have a name. This will become relevant when attaching metrics to the Client
hartmann6_metric = MockMetric(name="hartmann6")

hartmann6_metric.fetch(trial_index=-1, trial_metadata=trial_metadata)
```

<CellOutput>
{
`(0, -0.4878737485613134)`
}
</CellOutput>

## Step 3: Initialize the Client and Configure the Experiment

Finally, we can initialize the `Client` and configure the experiment as before. This
will be familiar to readers of the
[Getting Started with Ax tutorial](../getting_started) -- the only difference is we will
attach the previously defined Runner and Metric by calling `configure_runner` and
`configure_metrics` respectively.

Note that when initializing `hartmann6_metric` we set `name=hartmann6`, matching the
objective we now set in `configure_optimization`. The `configure_metrics` method uses
this name to ensure that data fetched by this Metric is used correctly during the
experiment. Be careful to correctly set the name of the Metric to reflect its use as an
objective or outcome constraint.

```python
client = Client()
# Define six float parameters for the Hartmann6 function
parameters = [
    RangeParameterConfig(name=f"x{i + 1}", parameter_type="float", bounds=(0, 1))
    for i in range(6)
]

client.configure_experiment(
    parameters=parameters,
    # The following arguments are only necessary when saving to the DB
    name="hartmann6_experiment",
    description="Optimization of the Hartmann6 function",
    owner="developer",
)
client.configure_optimization(objective="-hartmann6")
```

```python
client.configure_runner(runner=runner)
client.configure_metrics(metrics=[hartmann6_metric])
```

## Step 5: Run trials

Once the `Client` has been configured, we can begin running trials.

Internally, Ax uses a class named `Scheduler` to orchestrate the trial deployment,
polling, data fetching, and candidate generation.

![Scheduler state machine](assets/img/scheduler_state_machine.png)

The `run_trials` method provides users with control over various orchestration settings
as well as the total maximum number of trials to evaluate:

- `parallelism` defines the maximum number of trials that may be run at once. If your
  external system supports multiple evaluations in parallel, increasing this number can
  significantly decrease experimentation time. However, it is important to note that as
  parallelism increases, optimiztion performance often decreases. This is because
  adaptive experimentation methods rely on previously observed data for candidate
  generation -- the more tirals that have been observed prior to generation of a new
  candidate, the more accurate Ax's model will be for generation of that candidate.
- `tolerated_trial_failure_rate` sets the proportion of trials are allowed to fail
  before Ax raises an Exception. Depending on how expensive a single trial is to
  evaluate or how unreliable trials are expected to be, the experimenter may want to be
  notified as soon as a single trial fails or they may not care until more than half the
  trials are failing. Set this value as is appropriate for your context.
- `initial_seconds_between_polls` sets the frequency at which the status of a trial is
  checked and the results are attempted to be fetched. Set this to be low for trials
  that are expected to complete quickly or high for trials the are expected to take a
  long time.

```python
client.run_trials(
    max_trials=30,
    parallelism=3,
    tolerated_trial_failure_rate=0.1,
    initial_seconds_between_polls=1,
)
```

<CellOutput>
{
`[INFO 09-05 19:20:49] ax.api.client: GenerationStrategy(name='Center+Sobol+MBM:fast', nodes=[CenterGenerationNode(next_node_name='Sobol'), GenerationNode(node_name='Sobol', generator_specs=[GeneratorSpec(generator_enum=Sobol, model_key_override=None)], transition_criteria=[MinTrials(transition_to='MBM'), MinTrials(transition_to='MBM')]), GenerationNode(node_name='MBM', generator_specs=[GeneratorSpec(generator_enum=BoTorch, model_key_override=None)], transition_criteria=[])]) chosen based on user input and problem structure.
[INFO 09-05 19:20:49] Orchestrator: Orchestrator requires experiment to have immutable search space and optimization config. Setting property immutable_search_space_and_opt_config to True on experiment.
[INFO 09-05 19:20:49] Orchestrator: Running trials [0]...
[INFO 09-05 19:20:50] Orchestrator: Running trials [1]...
[INFO 09-05 19:20:51] Orchestrator: Running trials [2]...
[INFO 09-05 19:20:52] Orchestrator: Retrieved COMPLETED trials: 0 - 2.
[INFO 09-05 19:20:52] Orchestrator: Running trials [3]...
[INFO 09-05 19:20:53] Orchestrator: Running trials [4]...
[INFO 09-05 19:20:54] Orchestrator: Running trials [5]...
[INFO 09-05 19:20:55] Orchestrator: Retrieved COMPLETED trials: 3 - 5.
[INFO 09-05 19:20:56] Orchestrator: Running trials [6]...
[INFO 09-05 19:20:57] Orchestrator: Running trials [7]...
[INFO 09-05 19:20:59] Orchestrator: Running trials [8]...
[INFO 09-05 19:21:00] Orchestrator: Retrieved COMPLETED trials: 6 - 8.
[INFO 09-05 19:21:01] Orchestrator: Running trials [9]...
[INFO 09-05 19:21:02] Orchestrator: Running trials [10]...
[INFO 09-05 19:21:04] Orchestrator: Running trials [11]...
[INFO 09-05 19:21:05] Orchestrator: Retrieved COMPLETED trials: 9 - 11.
[INFO 09-05 19:21:06] Orchestrator: Running trials [12]...
[INFO 09-05 19:21:07] Orchestrator: Running trials [13]...
[INFO 09-05 19:21:09] Orchestrator: Running trials [14]...
[INFO 09-05 19:21:10] Orchestrator: Retrieved COMPLETED trials: 12 - 14.
[INFO 09-05 19:21:11] Orchestrator: Running trials [15]...
[INFO 09-05 19:21:12] Orchestrator: Running trials [16]...
[INFO 09-05 19:21:14] Orchestrator: Running trials [17]...
[INFO 09-05 19:21:15] Orchestrator: Retrieved COMPLETED trials: 15 - 17.
[INFO 09-05 19:21:16] Orchestrator: Running trials [18]...
[INFO 09-05 19:21:18] Orchestrator: Running trials [19]...
[INFO 09-05 19:21:20] Orchestrator: Running trials [20]...
[INFO 09-05 19:21:21] Orchestrator: Retrieved COMPLETED trials: 18 - 20.
[INFO 09-05 19:21:22] Orchestrator: Running trials [21]...
[INFO 09-05 19:21:23] Orchestrator: Running trials [22]...
[INFO 09-05 19:21:25] Orchestrator: Running trials [23]...
[INFO 09-05 19:21:26] Orchestrator: Retrieved COMPLETED trials: 21 - 23.
[INFO 09-05 19:21:27] Orchestrator: Running trials [24]...
[INFO 09-05 19:21:29] Orchestrator: Running trials [25]...
[INFO 09-05 19:21:31] Orchestrator: Running trials [26]...
[INFO 09-05 19:21:32] Orchestrator: Retrieved COMPLETED trials: 24 - 26.
[INFO 09-05 19:21:33] Orchestrator: Running trials [27]...
[INFO 09-05 19:21:35] Orchestrator: Running trials [28]...
[INFO 09-05 19:21:37] Orchestrator: Running trials [29]...
[INFO 09-05 19:21:38] Orchestrator: Retrieved COMPLETED trials: 27 - 29.`
}
</CellOutput>

## Step 6: Analyze Results

As before, Ax can compute the best parameterization observed and produce a number of
analyses to help interpret the results of the experiment.

It is also worth noting that the experiment can be resumed at any time using Ax's
storage functionality. When configured to use a SQL databse, the `Client` saves a
snapshot of itself at various points throughout the call to `run_trials`, making it
incredibly easy to continue optimization after an unexpected failure. You can learn more
about storage in Ax [here](../../recipes/experiment-to-json).

```python
best_parameters, prediction, index, name = client.get_best_parameterization()
print("Best Parameters:", best_parameters)
print("Prediction (mean, variance):", prediction)
```

<CellOutput>
{
`Best Parameters: {'x1': 0.0, 'x2': 0.03937819569143662, 'x3': 0.44538030264878953, 'x4': 0.26130139219702647, 'x5': 0.3174639734384757, 'x6': 0.6905230474387417}
Prediction (mean, variance): {'hartmann6': (np.float64(-2.6303452016586144), np.float64(0.0022475398218610816))}`
}
</CellOutput>

```python
# display=True instructs Ax to sort then render the resulting analyses
cards = client.compute_analyses(display=True)
```

**Modeled Arm Effects on hartmann6**

Modeled effects on hartmann6. This plot visualizes predictions of the true metric
changes for each arm based on Ax's model. This is the expected delta you would expect if
you (re-)ran that arm. This plot helps in anticipating the outcomes and performance of
arms based on the model's predictions. Note, flat predictions across arms indicate that
the model predicts that there is no effect, meaning if you were to re-run the
experiment, the delta you would see would be small and fall within the confidence
interval indicated in the plot.



<PlotlyFigure data={require('./assets/plot_data/fa581350-50c8-411e-a0ac-0a8ef3f69263.json')} />


**Observed Arm Effects on hartmann6**

Observed effects on hartmann6. This plot visualizes the effects from previously-run arms
on a specific metric, providing insights into their performance. This plot allows one to
compare and contrast the effectiveness of different arms, highlighting which
configurations have yielded the most favorable outcomes.



<PlotlyFigure data={require('./assets/plot_data/79d6ec18-553a-47b8-bca7-072de38fcca0.json')} />


**Summary for hartmann6_experiment**

High-level summary of the `Trial`-s in this `Experiment`




|    |   trial_index |   arm_name | trial_status   | generation_node     |   hartmann6 |       x1 |       x2 |       x3 |       x4 |       x5 |       x6 |
|---:|--------------:|-----------:|:---------------|:--------------------|------------:|---------:|---------:|---------:|---------:|---------:|---------:|
|  0 |             0 |        0_0 | COMPLETED      | CenterOfSearchSpace |   -0.505315 | 0.5      | 0.5      | 0.5      | 0.5      | 0.5      | 0.5      |
|  1 |             1 |        1_0 | COMPLETED      | Sobol               |   -0.003911 | 0.795128 | 0.335028 | 0.259777 | 0.083026 | 0.867723 | 0.404173 |
|  2 |             2 |        2_0 | COMPLETED      | Sobol               |   -0.056864 | 0.283303 | 0.971216 | 0.64394  | 0.607877 | 0.088022 | 0.87164  |
|  3 |             3 |        3_0 | COMPLETED      | Sobol               |   -1.46317  | 0.124154 | 0.180082 | 0.063729 | 0.477663 | 0.407776 | 0.664309 |
|  4 |             4 |        4_0 | COMPLETED      | Sobol               |   -0.115945 | 0.612359 | 0.513612 | 0.961076 | 0.955398 | 0.628059 | 0.071351 |
|  5 |             5 |        5_0 | COMPLETED      | MBM                 |   -0.471555 | 0.741653 | 0.395074 | 0.669567 | 0.417902 | 0.412911 | 0.453561 |
|  6 |             6 |        6_0 | COMPLETED      | MBM                 |   -1.31214  | 0.007419 | 0.089841 | 0        | 0.465252 | 0.263164 | 0.781473 |
|  7 |             7 |        7_0 | COMPLETED      | MBM                 |   -0.019553 | 0        | 0.092638 | 0        | 0.908377 | 0.503649 | 0.796024 |
|  8 |             8 |        8_0 | COMPLETED      | MBM                 |   -0.552755 | 0        | 0.152224 | 0        | 0.03329  | 0.366119 | 0.390094 |
|  9 |             9 |        9_0 | COMPLETED      | MBM                 |   -0.429747 | 0.023183 | 0.135499 | 0        | 0.42799  | 0.536766 | 0.417092 |
| 10 |            10 |       10_0 | COMPLETED      | MBM                 |   -0.337701 | 0.327598 | 0.150861 | 0        | 0.458035 | 0.577    | 0.888895 |
| 11 |            11 |       11_0 | COMPLETED      | MBM                 |   -0.640149 | 0.217431 | 0.208894 | 0        | 0.471797 | 0.116912 | 0.444206 |
| 12 |            12 |       12_0 | COMPLETED      | MBM                 |   -0.880225 | 0        | 0.078546 | 0        | 0.458916 | 0.126203 | 0.683191 |
| 13 |            13 |       13_0 | COMPLETED      | MBM                 |   -0.221053 | 0        | 0.034902 | 0        | 0.488006 | 0.62925  | 0.694388 |
| 14 |            14 |       14_0 | COMPLETED      | MBM                 |   -1.2058   | 0        | 0.331085 | 0        | 0.43112  | 0.195319 | 0.695869 |
| 15 |            15 |       15_0 | COMPLETED      | MBM                 |   -1.83969  | 0.080738 | 0.245658 | 0.028109 | 0.425452 | 0.336414 | 0.659198 |
| 16 |            16 |       16_0 | COMPLETED      | MBM                 |   -1.51705  | 0.499707 | 0.247572 | 0        | 0.4334   | 0.333055 | 0.665233 |
| 17 |            17 |       17_0 | COMPLETED      | MBM                 |   -1.98129  | 0        | 0        | 0.168426 | 0.394139 | 0.336997 | 0.667475 |
| 18 |            18 |       18_0 | COMPLETED      | MBM                 |   -1.87593  | 0        | 0        | 4.2e-05  | 0.285422 | 0.339089 | 0.672391 |
| 19 |            19 |       19_0 | COMPLETED      | MBM                 |   -2.42689  | 0        | 0        | 0.593928 | 0.329481 | 0.327496 | 0.663399 |
| 20 |            20 |       20_0 | COMPLETED      | MBM                 |   -1.75353  | 0        | 0        | 0        | 0.365753 | 0.317556 | 0.60892  |
| 21 |            21 |       21_0 | COMPLETED      | MBM                 |   -1.36857  | 0        | 0.100289 | 0.93366  | 0.187048 | 0.328689 | 0.68649  |
| 22 |            22 |       22_0 | COMPLETED      | MBM                 |   -0.250576 | 0        | 0.882753 | 0.870383 | 0.185923 | 0.33877  | 0.681884 |
| 23 |            23 |       23_0 | COMPLETED      | MBM                 |   -1.10081  | 0        | 0        | 1        | 0.375929 | 0.30448  | 0.659112 |
| 24 |            24 |       24_0 | COMPLETED      | MBM                 |   -2.68497  | 0        | 0.039378 | 0.44538  | 0.261301 | 0.317464 | 0.690523 |
| 25 |            25 |       25_0 | COMPLETED      | MBM                 |   -2.39517  | 0        | 0        | 0.487894 | 0.263909 | 0.370932 | 0.727702 |
| 26 |            26 |       26_0 | COMPLETED      | MBM                 |   -2.55535  | 0        | 0        | 0.467827 | 0.255969 | 0.27255  | 0.641343 |
| 27 |            27 |       27_0 | COMPLETED      | MBM                 |   -2.61265  | 0        | 0.11566  | 0.435648 | 0.229309 | 0.28618  | 0.732439 |
| 28 |            28 |       28_0 | COMPLETED      | MBM                 |   -2.61442  | 0.338402 | 0        | 0.457702 | 0.205799 | 0.282597 | 0.726742 |
| 29 |            29 |       29_0 | COMPLETED      | MBM                 |   -2.73637  | 0        | 0.163215 | 0.405617 | 0.229967 | 0.315534 | 0.667629 |


**Sensitivity Analysis for hartmann6**

Understand how each parameter affects hartmann6 according to a second-order sensitivity
analysis.



<PlotlyFigure data={require('./assets/plot_data/5ca78fc3-e09a-43c6-b285-d0190af0c699.json')} />


**x5 vs. hartmann6**

The slice plot provides a one-dimensional view of predicted outcomes for hartmann6 as a
function of a single parameter, while keeping all other parameters fixed at their
status_quo value (or mean value if status_quo is unavailable). This visualization helps
in understanding the sensitivity and impact of changes in the selected parameter on the
predicted metric outcomes.



<PlotlyFigure data={require('./assets/plot_data/e8c3e1ca-c4ea-4055-9ff6-509c11160e0a.json')} />


**x6 vs. hartmann6**

The slice plot provides a one-dimensional view of predicted outcomes for hartmann6 as a
function of a single parameter, while keeping all other parameters fixed at their
status_quo value (or mean value if status_quo is unavailable). This visualization helps
in understanding the sensitivity and impact of changes in the selected parameter on the
predicted metric outcomes.



<PlotlyFigure data={require('./assets/plot_data/a594c59e-d138-4fac-a0ea-398e42d55c2e.json')} />


**x5, x6 vs. hartmann6**

The contour plot visualizes the predicted outcomes for hartmann6 across a
two-dimensional parameter space, with other parameters held fixed at their status_quo
value (or mean value if status_quo is unavailable). This plot helps in identifying
regions of optimal performance and understanding how changes in the selected parameters
influence the predicted outcomes. Contour lines represent levels of constant predicted
values, providing insights into the gradient and potential optima within the parameter
space.



<PlotlyFigure data={require('./assets/plot_data/2ebf1a77-3882-422a-96cf-f0ff63bd79a2.json')} />


**Cross Validation for hartmann6**

The cross-validation plot displays the model fit for each metric in the experiment. It
employs a leave-one-out approach, where the model is trained on all data except one
sample, which is used for validation. The plot shows the predicted outcome for the
validation set on the y-axis against its actual value on the x-axis. Points that align
closely with the dotted diagonal line indicate a strong model fit, signifying accurate
predictions. Additionally, the plot includes 95% confidence intervals that provide
insight into the noise in observations and the uncertainty in model predictions. A
horizontal, flat line of predictions indicates that the model has not picked up on
sufficient signal in the data, and instead is just predicting the mean.



<PlotlyFigure data={require('./assets/plot_data/3d5f5b6b-d301-4830-9699-ef167fe91cce.json')} />

## Conclusion

This tutorial demonstrates how to use Ax's `Client` for closed-loop optimization using
the Hartmann6 function as an example. This style of optimization is useful in scenarios
where trials are evaluated on some external system or when experimenters wish to take
advantage of parallel evaluation, trial failure handling, or simply to manage
long-running optimization tasks without human intervention. You can define your own
Runner and Metric classes to communicate with whatever external systems you wish to
interface with, and control optimization using the `OrchestrationConfig`.

